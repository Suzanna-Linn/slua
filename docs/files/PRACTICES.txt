practice1 = [[ rewrite this script using a closure to avoid needing a script-wide variable

local isOpen = false

function touch_start(total_number)
    if isOpen then
        print("Closing the door...");
        -- something to close the door
        isOpen = false;
    else
        print("Opening the door...");
        -- something to open the door
        isOpen = true;
    end
end
]]

local function doorClosure()
    local isOpen
    return function()
        if isOpen then
            print("Closing the door...");
            -- something to close the door
            isOpen = false;
        else
            print("Opening the door...");
            -- something to open the door
            isOpen = true;
        end
    end
end

local door = doorClosure()

function touch_start(total_number)
    door()
end


-- alternative version

local door = (function ()
    local isOpen
    return function()
        if isOpen then
            print("Closing the door...");
            -- something to close the door
            isOpen = false;
        else
            print("Opening the door...");
            -- something to open the door
            isOpen = true;
        end
    end
end)()

function touch_start(total_number)
    door()
end



practice2a = [[ (version 1) - write a closure to add elements to a "to-do list", test with:

list1 = todoList()
list1("task1")  -- > task1
list1("task2")  -- > task1, task2

list2 = todoList()
list2("issue1")  -- > issue 1
]]

local function todoList()
    local list = {}
    return function(item)
        table.insert(list, item)
        print(table.concat(list, ", "))
    end
end

local list1 = todoList()
list1("task1")  -- > task1
list1("task2")  -- > task1, task2

local list2 = todoList()
list2("issue1")  -- > issue 1



practice2b = [[ (version 2) - improve the closure to add to, remove from, and list the "to-do list", test with:

list1add, list1done, list1list = todoList()
list1add("task1")
list1add("task2")
list1list()  -- > task1, task2
list1done("task1")
list1list()  -- > task2

list2add, list2done, list2list = todoList()
list2add("issue1")
list2list()  -- > issue 1
]]

local function todoList()
    local list = {}
    return
    function(item)  -- add
        table.insert(list, item)
    end,
    function(item)  -- done
        local index = table.find(list, item)
        if index then
            table.remove(list, index)
        end
    end,
    function()  -- list
        print(table.concat(list, ", "))
    end
end

local list1add, list1done, list1list = todoList()
list1add("task1")
list1add("task2")
list1list()  -- > task1, task2
list1done("task1")
list1list()  -- > task2

local list2add, list2done, list2list = todoList()
list2add("issue1")
list2list()  -- > issue 1



practice2c = [[ (version 3) - improve the closure to have the three functions in a table, test with:

list1 = todoList()
list1.add("task1")
list1.add("task2")
list1.list()  -- > task1, task2
list1.done("task1")
list1.list()  -- > task2

list2 = todoList()
list2.add("issue1")
list2.list()  -- > issue1
]]

local function todoList()
    local list = {}
    return {
        add = function(item)  -- add
            table.insert(list, item)
        end,
        done = function(item)  -- done
            local index = table.find(list, item)
            if index then
                table.remove(list, index)
            end
        end,
        list = function()  -- list
            print(table.concat(list, ", "))
        end
    }
end

local list1 = todoList()
list1.add("task1")
list1.add("task2")
list1.list()  -- > task1, task2
list1.done("task1")
list1.list()  -- > task2

local list2 = todoList()
list2.add("issue1")
list2.list()  -- > issue1



practice3a = [[ (version 1) - write an iterator to iterate on all the prims and faces of the object, test with:

print("\n----- all prims and faces -----\n")
for prim, face in iterPrimsFaces() do
    print(`Prim: {prim}, Face: {face}`)
end

useful functions:
ll.GetNumberOfPrims()
ll.GetLinkNumberOfSides(prim)
]]

local function iterPrimsFaces()
    local prim = 1
    local lastPrim = ll.GetNumberOfPrims()
    if lastPrim == 1 then
        prim = 0
        lastPrim = 0
    end
    local faces = ll.GetLinkNumberOfSides(prim)
    local face = -1
    return function()
        face += 1
        if face == faces then
            prim += 1
            if prim > lastPrim then
                return nil
            end
            faces = ll.GetLinkNumberOfSides(prim)
            face = 0
        end
        return prim, face
    end
end

print("\n----- all prims and faces -----\n")
for prim, face in iterPrimsFaces() do
    print(`Prim: {prim}, Face: {face}`)
end



practice3b = [[ (version 2) - improve the iterator with a filter function, test width:

print("\n----- all prims and faces -----\n")
for prim, face in iterPrimsFaces() do
    print(`Prim: {prim}, Face: {face}`)
end

print("\n----- prims with name 'test' -----\n")
for prim, face in iterPrimsFaces(function(prim, face, selName)
        if face == 0 then
            return ll.GetLinkName(prim) == selName
        else
            return false
        end
    end, "test") do
    print(`Prim: {prim}`)
end

print("\n----- prims and faces with color red (1,0,0) -----\n")
for prim, face in iterPrimsFaces(function(prim, face, selColor)
        return ll.GetLinkPrimitiveParams(prim, { PRIM_COLOR, face })[1] == selColor
    end, vector(1, 0, 0)) do
    print(`Prim: {prim}, Face: {face}`)
end

print("\n----- prims and faces with transparency -----\n")
for prim, face, alpha in iterPrimsFaces(function(prim, face)
        local alpha = ll.GetLinkPrimitiveParams(prim, { PRIM_COLOR, face })[2]
        if alpha < 1 then
            return true, alpha
        else
            return false
        end
    end) do
    print(`Prim: {prim}, Face: {face}, Alpha: {alpha}`)
end

useful functions:
ll.GetNumberOfPrims()
ll.GetLinkNumberOfSides(prim)
]]

local function iterPrimsFaces(filter, ...)
    local param = {...}
    local prim = 1
    local lastPrim = ll.GetNumberOfPrims()
    if lastPrim == 1 then
        prim = 0
        lastPrim = 0
    end
    local faces = ll.GetLinkNumberOfSides(prim)
    local face = 0
    return function()
        repeat
            repeat
                face += 1
                if not (face > faces) then
                    local curFace = face - 1
                    if not filter then
                        return prim, curFace
                    else
                        local res = { filter(prim, curFace, table.unpack(param)) }
                        if res[1] == true then
                            return prim, curFace, select(2, table.unpack(res))
                        end
                    end
                end
            until face > faces
            prim += 1
            faces = ll.GetLinkNumberOfSides(prim)
            face = 0
        until prim > lastPrim
    end
end

print("\n----- all prims and faces -----\n")
for prim, face in iterPrimsFaces() do
    print(`Prim: {prim}, Face: {face}`)
end

print("\n----- prims with name 'test' -----\n")
for prim, face in iterPrimsFaces(function(prim, face, selName)
        if face == 0 then
            return ll.GetLinkName(prim) == selName
        else
            return false
        end
    end, "test") do
    print(`Prim: {prim}`)
end

print("\n----- prims and faces with color red (1,0,0) -----\n")
for prim, face in iterPrimsFaces(function(prim, face, selColor)
        return ll.GetLinkPrimitiveParams(prim, { PRIM_COLOR, face })[1] == selColor
    end, vector(1, 0, 0)) do
    print(`Prim: {prim}, Face: {face}`)
end

print("\n----- prims and faces with transparency -----\n")
for prim, face, alpha in iterPrimsFaces(function(prim, face)
        local alpha = ll.GetLinkPrimitiveParams(prim, { PRIM_COLOR, face })[2]
        if alpha < 1 then
            return true, alpha
        else
            return false
        end
    end) do
    print(`Prim: {prim}, Face: {face}, Alpha: {alpha}`)
end


--[[
local primsFaces = iterPrimsFaces()

while true do
    prim, face = primsFaces()
    if prim == nil then
        break
    end
    print(`Prim: {prim}, Face: {face}`)
end
]]
