function calculateSquareRoot(number)
   return math.sqrt(number)
end

function safeSquareRoot(input)
   local success, result = pcall(calculateSquareRoot, input)
   if success then
       print("The square root is:", result)
   else
       print("Error in", result) 
   end
end

safeSquareRoot(25) -- The square root is: 5.0
safeSquareRoot("hello") -- Error in lua_Script:2: invalid argument #1 to 'sqrt' (number expected, got string)



function calculateSquareRoot(number)
   return math.sqrt(number)
end

function safeSquareRoot(input)
   local success, result = pcall(calculateSquareRoot, input)
   if success then
       print("The square root is:", result)
   else
       print("Error in", result) 
   end
end

safeSquareRoot(25) -- The square root is: 5.0
safeSquareRoot("hello") -- Error in lua_Script:2: invalid argument #1 to 'sqrt' (number expected, got string)



local function safeDivide(a: number, b: number): number
    if b == 0 then
        error("Division by zero",2)
    end
    return a / b
end

print(safeDivide(10, 2))  -- 5
print(safeDivide(5, 0))   -- lua.script:9: Division by zero



local function safeDivide(a, b)
    if b == 0 then
        local func, line = debug.info(2, "nl")
        error(`Error in {if func ~= "" then "function ".. func else "main script"} at line {line}: Division by zero`,2)
    end
    return a / b
end

print(safeDivide(10, 2))  -- 5
print(safeDivide(5, 0))   -- lua.Script:10: Error in main script at line 10: Division by zero



local errors = {}

local function risky()
    local num = math.random(25)
    if num == 13 then
        table.insert(errors, debug.traceback("Bad luck!\n,"))
        error("Bad luck!")
    end
end

function test()
    math.randomseed(os.time())
    for i = 1, 100 do
        local success, result
        repeat
            success, result = pcall(risky)
            -- do something with result
        until success
    end
    for _, err in errors do
        print("---------------")
        print(err)
    end
end

test()



local function formatError(message)
    local func, line = debug.info(3,"nl")
    message = `\nerror in {if func ~= "" then "function ".. func else "main script"} at line {line}:\n{message}\n`
    return message
end

local function setHealth(playerName, health)
    assert(type(playerName) == "string", formatError("Expected player name as string"))
    assert(type(health) == "number" and health >= 0, formatError("Health must be a non-negative number"))
    -- do something
end

setHealth("Suzanna", 100)        -- OK
setHealth("Random Linden", -10)  -- Will trigger assert with debug info



local function formatError(message)
    local func, line = debug.info(3,"nl")
    message = `\nerror in {if func ~= "" then "function ".. func else "main script"} at line {line}:\n{message}\n`
    return message
end

local function process(param1, param2, callback)
    assert(typeof(callback) == "function" and debug.info(callback, "a") == 2, formatError("Expected a callback function with 2 parameters"))
    return callback(param1, param2)
end

local function sum(a, b)
    return a + b
end

local function double(a)
    return a * 2
end

print(process(3, 4, sum))
print(process(10, 20, double))



local function err(message)
    local errors = {
        ["call a nil value"] = "CHECK TYPOS, OR MISSING . IN A LL FUNCTION, ON THE LEFT OF ()",
        ["index nil with"] = "CHECK TYPOS ON THE LEFT OF []",
        ["perform arithmetic (add) on string"] = "CHECK USE OF .. (NOT +) TO CONCATENATE STRINGS",
        ["call a table value"] = "CHECK USE OF [] (NOT ()) TO INDEX A TABLE",
        ["concatenate nil with string"] = "CHECK TYPOS ON THE LEFT OF ..",
        ["concatenate string with nil"] = "CHECK TYPOS ON THE RIGHT OF ..",
    }
    local func, line = debug.info(2,"nl")
    local suggest = ""
    for msg in errors do
        if message:find(msg, 1, true) then
            suggest = `\n{errors[msg]} at line {line-1}\n\n`
            break
        end
    end
    message = `\nerror in {if func ~= "" then "function ".. func else "main script"} at line {line}:\n{message}\n{suggest}`
    return message
end

local function runTimeError1()
    _()
end

local function runTimeError2()
    local a, b = "a", "b"
    print(a+b)
end

-- local ok, result = xpcall(runTimeError1,err)
-- if not ok then error(result) end

local ok, result = xpcall(runTimeError2,err)
if not ok then error(result) end



local function numberGenerator()
	for i = 1, 3 do
		coroutine.yield(i)
	end
	return 4
end

local co = coroutine.create(numberGenerator)

local success, value = coroutine.resume(co)
print(value) -- > 1
success, value = coroutine.resume(co)
print(value) -- > 2
success, value = coroutine.resume(co)
print(value) -- > 3
success, value = coroutine.resume(co)
print(value) -- > 4
success, value = coroutine.resume(co)
print(value)  -- >   cannot resume dead coroutine



function wrap(func)
	local co = coroutine.create(func)
	return function(...)
		local results = table.pack(coroutine.resume(co, ...))
		local success = results[1]
		if success then
			return table.unpack(results, 2, results.n)
		else
			local errorMessage = results[2]
			error(errorMessage)
		end
	end
end

local function numberGenerator()
	for i = 1, 3 do
		coroutine.yield(i)
	end
	return 4
end

local generate = wrap(numberGenerator)

print(generate()) -- > 1
print(generate()) -- > 2
print(generate()) -- > 3
print(generate()) -- > 4
print(pcall(generate))  -- > false    cannot resume dead coroutine



local function numberGenerator()
	for i = 1, 3 do
		coroutine.yield(i)
	end
	return 4
end

local generate = coroutine.wrap(numberGenerator)

print(generate()) -- > 1
print(generate()) -- > 2
print(generate()) -- > 3
print(generate()) -- > 4
print(pcall(generate))  -- > false    cannot resume dead coroutine
