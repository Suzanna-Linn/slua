local Shape = {}
Shape.__index = Shape
Shape.attribute_order = {"id", "class", "style", "fill", "stroke", "stroke_width", "opacity"}
Shape._instances = setmetatable({}, {__mode = "v"})

-- fill (string): Fill color (e.g., "red", "#ff0000", "none")
-- stroke (string): Stroke color
-- stroke_width (number): Stroke width in pixels
-- opacity (number): Opacity (0 to 1)
-- id (string): Optional HTML id
-- class (string): CSS class name
-- style (string): Inline style
function Shape:new(props)
	assert(self ~= Shape, "Shape is an abstract concept, use a specific shape")
	props = props or {}
	local shape = setmetatable({
		fill = props.fill or "none",
		stroke = props.stroke or "none",
		stroke_width = props.stroke_width or 1,
		opacity = props.opacity or 1,
		id = props.id or "",
		class = props.class or "",
		style = props.style or "",
		transform = {},
	}, self)
	table.insert(Shape._instances, shape)
	return shape
end

-- dx (number): Horizontal translation distance (pixels).
-- dy (number): Vertical translation distance (pixels). Defaults to 0.
function Shape:translate(dx, dy)
	table.insert(self.transform, `translate({dx}, {dy or 0})`)
	return self
end

-- sx (number): Horizontal scale factor.
-- sy (number): Vertical scale factor. Defaults to sx (uniform scaling).
function Shape:scale(sx, sy)
	table.insert(self.transform, `scale({sx}, {sy or sx})`)
	return self
end

-- angle (number): Rotation angle in degrees.
-- cx (number): X-coordinate of the rotation center. If omitted, rotation is around the origin (0,0).
-- cy (number): Y-coordinate of the rotation center.
function Shape:rotate(angle, cx, cy)
	if cx and cy then
		table.insert(self.transform, `rotate({angle}, {cx}, {cy})`)
	else
		table.insert(self.transform, `rotate({angle})`)
	end
	return self
end

-- angle (number): Skew angle in degrees along the X-axis.
function Shape:skewX(angle)
	table.insert(self.transform, `skewX({angle})`)
	return self
end

-- angle (number): Skew angle in degrees along the Y-axis.
function Shape:skewY(angle)
	table.insert(self.transform, `skewY({angle})`)
	return self
end

function Shape:clearTransform()
	self.transform = {}
end

function Shape:_attributes()
	local attr = {}
	local combined_order = {}
	local class = getmetatable(self)
	while class do
		local order = rawget(class, "attribute_order")
		if order then
			for _, name in ipairs(order) do
				if not table.find(combined_order, name) then
					table.insert(combined_order, name)
				end
			end
		end
		local mt = getmetatable(class)
		class = mt and mt.__index or nil
	end
	for _, prop in ipairs(combined_order) do
		local value = self[prop]
		local attrName = string.gsub(prop, "_", "-")
		if value ~= nil and value ~= "" then
			table.insert(attr, `{attrName}="{value}"`)
		end
	end
	if self.transform and #self.transform > 0 then
		table.insert(attr, `transform="{table.concat(self.transform, " ")}"`)
	end
	return table.concat(attr, " ")
end

function Shape:_SVG(tagname, content)
	if content then
		return `<{tagname} {self:_attributes()}>{content}</{tagname}>`
	else
		return `<{tagname} {self:_attributes()} />`
	end
end

function Shape:__tostring()
	return ""
end

function Shape.draw()
	local svgElements = {}
	for _, shape in ipairs(Shape._instances) do
		if shape.__tostring then
			table.insert(svgElements, tostring(shape))
		end
	end
	local xhtml = [[
<!DOCTYPE html
     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>SVG Shapes</title>
  <style type="text/css">
    svg { border: 1px solid #ccc; }
  </style>
</head>
<body>
  <svg width="800" height="600" xmlns="http://www.w3.org/2000/svg" version="1.1">
]] .. table.concat(svgElements, "\n") .. [[
  </svg>
</body>
</html>
]]
	return xhtml
end


local Rect = {}
Rect.__index = Rect
Rect.attribute_order = {"x", "y", "width", "height", "rx", "ry"}
setmetatable(Rect, {
	__index = Shape,
	__call = function(class, ...)
		return class:new(...)
	end
})

-- x (number): Top-left x position
-- y (number): Top-left y position
-- width (number): Width of the rectangle
-- height (number): Height of the rectangle
-- rx (number): Optional corner radius x (horizontal rounding)
-- ry (number): Optional corner radius y (vertical rounding)
function Rect:new(props)
	props = props or {}
	local rect = Shape.new(self, props)
	rect.x = props.x or 0
	rect.y = props.y or 0
	rect.width = props.width or 100
	rect.height = props.height or 100
	rect.rx = props.rx
	rect.ry = props.ry
	return rect
end

function Rect:__tostring()
	return self:_SVG("rect")
end


local Circle = {}
Circle.__index = Circle
Circle.attribute_order = {"cx", "cy", "r"}
setmetatable(Circle, {
	__index = Shape,
	__call = function(class, ...)
		return class:new(...)
	end
})

-- cx (number): Center x position
-- cy (number): Center y position
-- r (number): Radius
function Circle:new(props)
	props = props or {}
	local circle = Shape.new(self, props)
	circle.cx = props.cx or 0
	circle.cy = props.cy or 0
	circle.r = props.r or 50
	return circle
end

function Circle:__tostring()
	return self:_SVG("circle")
end


local Ellipse = {}
Ellipse.__index = Ellipse
Ellipse.attribute_order = {"cx", "cy", "rx", "ry"}

setmetatable(Ellipse, {
	__index = Shape,
	__call = function(class, ...)
		return class:new(...)
	end
})

-- cx (number): Center x
-- cy (number): Center y
-- rx (number): Horizontal radius
-- ry (number): Vertical radius
function Ellipse:new(props)
	props = props or {}
	local ellipse = Shape.new(self, props)
	ellipse.cx = props.cx or 0
	ellipse.cy = props.cy or 0
	ellipse.rx = props.rx or 50
	ellipse.ry = props.ry or 25
	return ellipse
end

function Ellipse:__tostring()
	return self:_SVG("ellipse")
end


local Line = {}
Line.__index = Line
Line.attribute_order = {"x1", "y1", "x2", "y2"}

setmetatable(Line, {
	__index = Shape,
	__call = function(class, ...)
		return class:new(...)
	end
})

-- x1 (number): Start x
-- y1 (number): Start y
-- x2 (number): End x
-- y2 (number): End y
function Line:new(props)
	props = props or {}
	local line = Shape.new(self, props)
	line.x1 = props.x1 or 0
	line.y1 = props.y1 or 0
	line.x2 = props.x2 or 100
	line.y2 = props.y2 or 100
	return line
end

function Line:__tostring()
	return self:_SVG("line")
end


local Text = {}
Text.__index = Text
Text.attribute_order = {"x", "y", "fill", "font_family", "font_size", "font_weight"}
setmetatable(Text, {
	__index = Shape,
	__call = function(class, ...)
		return class:new(...)
	end
})

-- x (number): Start x position
-- y (number): Baseline y position
-- fill (string): Text color
-- font_family (string): Font family
-- font_size (number): Font size in px
-- font_weight (string): "normal", "bold", etc.
-- content (string): Text content
function Text:new(props)
	props = props or {}
	local text = Shape.new(self, props)
	text.x = props.x or 0
	text.y = props.y or 0
	text.fill = props.fill or "black"
	text.font_family = props.font_family or "Arial, sans-serif"
	text.font_size = props.font_size or 16
	text.font_weight = props.font_weight or "normal"
	text.content = props.content or ""
	return text
end

function Text:__tostring()
	return self:_SVG("text", self.content)
end


local Image = {}
Image.__index = Image
Image.attribute_order = {"x", "y", "width", "height", "href"}
setmetatable(Image, {
	__index = Shape,
	__call = function(class, ...)
		return class:new(...)
	end
})

-- x (number): Top-left x
-- y (number): Top-left y
-- width (number): Width in pixels
-- height (number): Height in pixels
-- href (string): Image URL
function Image:new(props)
	props = props or {}
	local image = Shape.new(self, props)
	image.x = props.x or 0
	image.y = props.y or 0
	image.width = props.width or 100
	image.height = props.height or 100
	image.href = props.href or ""
	return image
end

function Image:__tostring()
	return self:_SVG("image")
end


local Polygon = {}
Polygon.__index = Polygon
Polygon.attribute_order = {"points"}
setmetatable(Polygon, {
	__index = Shape,
	__call = function(class, ...)
		return class:new(...)
	end
})

-- points (string): Space-separated list of x,y pairs
function Polygon:new(props)
	props = props or {}
	local polygon = Shape.new(self, props)
	polygon.points = props.points or ""
	return polygon
end

function Polygon:__tostring()
	return self:_SVG("polygon")
end


local Polyline = {}
Polyline.__index = Polyline
Polyline.attribute_order = {"points", "fill", "stroke", "stroke_width"}
setmetatable(Polyline, {
	__index = Shape,
	__call = function(class, ...)
		return class:new(...)
	end
})

-- points (string): Space-separated x,y pairs
function Polyline:new(props)
	props = props or {}
	local polyline = Shape.new(self, props)
	polyline.points = props.points or ""
	return polyline
end

function Polyline:__tostring()
	return self:_SVG("polyline")
end

local Path = {}
Path.__index = Path
Path.attribute_order = {"d"}
setmetatable(Path, {
	__index = Shape,
	__call = function(class, ...)
		return class:new(...)
	end
})

-- d (string): SVG path commands (e.g., "M 10 10 L 100 100")
function Path:new(props)
	props = props or {}
	local path = Shape.new(self, props)
	path.d = props.d or ""
	return path
end

function Path:__tostring()
	return self:_SVG("path")
end


local Triangle = {}
Triangle.__index = Triangle
Triangle.attribute_order = {"points"}

setmetatable(Triangle, {
	__index = Polygon,
	__call = function(class, ...)
		return class:new(...)
	end
})

-- x1, y1: First point
-- x2, y2: Second point
-- x3, y3: Third point
function Triangle:new(props)
	props = props or {}
	local x1 = props.x1 or 0
	local y1 = props.y1 or 0
	local x2 = props.x2 or 100
	local y2 = props.y2 or 0
	local x3 = props.x3 or 50
	local y3 = props.y3 or 100
	local triangle = Polygon.new(self, props)
	triangle.points = `{x1},{y1} {x2},{y2} {x3},{y3}`
	return triangle
end

function Triangle:__tostring()
	return self:_SVG("polygon")
end


local RegularPolygon = {}
RegularPolygon.__index = RegularPolygon
RegularPolygon.attribute_order = {"points"}

setmetatable(RegularPolygon, {
	__index = Polygon,
	__call = function(class, ...)
		return class:new(...)
	end
})

-- cx, cy (number): Center of the polygon
-- radius (number): Distance from center to each vertex
-- sides (number): Number of sides (minimum 3)
function RegularPolygon:new(props)
	props = props or {}
	local cx = props.cx or 0
	local cy = props.cy or 0
	local radius = props.radius or 50
	local sides = math.max(3, props.sides or 3)
	local angle_step = (2 * math.pi) / sides
	local points = {}
	for i = 0, sides - 1 do
		local angle = i * angle_step  -- starts at 0 radians (pointing right)
		local x = cx + radius * math.cos(angle)
		local y = cy + radius * math.sin(angle)
		table.insert(points, `{x},{y}`)
	end
	local regularPolygon = Polygon.new(self, props)
	regularPolygon.points = table.concat(points, " ")
	return regularPolygon
end

function RegularPolygon:__tostring()
	return self:_SVG("polygon")
end


local Star = {}
Star.__index = Star
Star.attribute_order = {"points"}  -- only needs the final 'points' string

setmetatable(Star, {
	__index = Polygon,
	__call = function(class, ...)
		return class:new(...)
	end
})

-- cx, cy (number): Center position
-- r_outer (number): Radius of outer tips
-- r_inner (number): Radius of inner valleys
-- points (number): Number of points (5 = pentagram)
function Star:new(props)
	props = props or {}
	local cx = props.cx or 0
	local cy = props.cy or 0
	local r_outer = props.r_outer or 50
	local r_inner = props.r_inner or (r_outer * 0.5)
	local num_points = props.points or 5
	local angle_step = math.pi / num_points
	local points = {}
	for i = 0, 2 * num_points - 1 do
		local r = (i % 2 == 0) and r_outer or r_inner
		local angle = i * angle_step - math.pi / 2
		local x = cx + r * math.cos(angle)
		local y = cy + r * math.sin(angle)
		table.insert(points, `{x},{y}`)
	end
	local star = Polygon.new(Polygon, props)
	star.points = table.concat(points, " ")
	return star
end

function Star:__tostring()
	return self:_SVG("polygon")
end


local Arrow = {}
Arrow.__index = Arrow
Arrow.attribute_order = {"points"}

setmetatable(Arrow, {
	__index = Polygon,
	__call = function(class, ...)
		return class:new(...)
	end
})

-- x, y (number): Base center position
-- length (number): Total arrow length
-- width (number): Shaft width
-- head_length (number): Length of arrowhead
-- head_width (number): Width of arrowhead
-- rotation (number): Optional rotation in degrees
function Arrow:new(props)
	props = props or {}
	local x = props.x or 0
	local y = props.y or 0
	local length = props.length or 100
	local width = props.width or 10
	local head_length = props.head_length or 20
	local head_width = props.head_width or (width * 2)
	local rotation = props.rotation or 0
	local shaft_length = length - head_length
	local half_width = width / 2
	local half_head = head_width / 2
	local points = {
		`{x - half_width},{y}`,
		`{x - half_width},{y - shaft_length}`,
		`{x - half_head},{y - shaft_length}`,
		`{x},{y - length}`,
		`{x + half_head},{y - shaft_length}`,
		`{x + half_width},{y - shaft_length}`,
		`{x + half_width},{y}`
	}
	local arrow = Polygon.new(Polygon, props)
	arrow.points = table.concat(points, " ")
	if rotation ~= 0 then
		arrow:rotate(rotation, x, y)
	end
	return arrow
end

function Arrow:__tostring()
	return self:_SVG("polygon")
end


local ZigZag = {}
ZigZag.__index = ZigZag
ZigZag.attribute_order = {"points"}

setmetatable(ZigZag, {
	__index = Polyline,
	__call = function(class, ...)
		return class:new(...)
	end
})

-- x, y (number): Start position
-- width (number): Total horizontal span
-- height (number): Vertical height of each step
-- steps (number): Number of zigzag segments
-- rotation (number): Optional rotation in degrees
function ZigZag:new(props)
	props = props or {}
	local x, y = props.x or 0, props.y or 0
	local width = props.width or 100
	local height = props.height or 20
	local steps = props.steps or 5
	local rotation = props.rotation or 0
	local points = {}
	for i = 0, steps do
		local px = x + (i * width / steps)
		local py = y + ((i % 2 == 0) and 0 or height)
		table.insert(points, `{px},{py}`)
	end
	props.points = table.concat(points, " ")
	local zigzag = Polyline(props)
	if rotation ~= 0 then
		zigzag:rotate(rotation, x, y)
	end
	return zigzag
end

function ZigZag:__tostring()
	return self:_SVG("polyline")
end


local Wave = {}
Wave.__index = Wave
Wave.attribute_order = {"d"}

setmetatable(Wave, {
	__index = Path,
	__call = function(class, ...)
		return class:new(...)
	end
})

-- x, y (number): Start position
-- width (number): Total horizontal length
-- amplitude (number): Wave height
-- cycles (number): Number of sine cycles
-- steps (number): Smoothness (more = smoother)
-- rotation (number): Optional rotation in degrees
function Wave:new(props)
	props = props or {}
	local x, y = props.x or 0, props.y or 0
	local width = props.width or 100
	local amplitude = props.amplitude or 20
	local cycles = props.cycles or 2
	local steps = props.steps or 20
	local rotation = props.rotation or 0
	local d = {}
	local step = width / steps
	for i = 0, steps do
		local px = x + i * step
		local py = y + math.sin(i / steps * cycles * 2 * math.pi) * amplitude
		if i == 0 then
			table.insert(d, `M {px} {py}`)
		else
			table.insert(d, `L {px} {py}`)
		end
	end
	props.d = table.concat(d, " ")
	local wave = Path(props)
	if rotation ~= 0 then
		wave:rotate(rotation, x, y)
	end
	return wave
end

function Wave:__tostring()
	return self:_SVG("path")
end


-- Simple rectangle
Rect{ x=10, y=10, width=100, height=60, fill="skyblue", stroke="black" }

-- Circle
Circle{ cx=200, cy=40, r=30, fill="pink" }

-- Ellipse
Ellipse{ cx=300, cy=40, rx=40, ry=20, fill="lightgreen" }

-- Line
Line{ x1=350, y1=10, x2=450, y2=70, stroke="purple", stroke_width=2 }

-- Text
Text{
	x=20, y=120, content="Hello SVG!",
	font_family="Georgia", font_size=18, fill="black"
}

-- Image (you can replace the href with a valid image URL if needed)
Image{
	x=480, y=10, width=50, height=50,
	href="https://upload.wikimedia.org/wikipedia/commons/4/47/PNG_transparency_demonstration_1.png"
}

-- Polygon: pentagon
Polygon{
	points="600,20 630,70 670,70 700,20 650,0",
	fill="orange"
}

-- Polyline: zigzag path
ZigZag{
	x=10, y=150, width=100, height=30, steps=7,
	stroke="red", fill="none", stroke_width=2,
	rotation=10
}

-- Path: wave
Wave{
	x=150, y=180, width=200, amplitude=15, cycles=3,
	stroke="blue", fill="none", stroke_width=2,
	rotation=-10
}

-- Triangle: basic
Triangle{ x1=400, y1=180, x2=460, y2=180, x3=430, y3=130, fill="gold" }


-- Regular Polygon: 6 sides
RegularPolygon{
	cx = 300, cy = 400, radius = 100, sides = 6,
	fill = "red", stroke = "black", stroke_width = 2
}

-- Star: 5-pointed
Star{
	cx=100, cy=300, r1=40, r2=20, points=5,
	fill="violet"
}

-- Arrow: pointing up
Arrow{
	x=200, y=280, length=80, width=20,
	fill="black", rotation=0
}

-- Arrow: pointing right
Arrow{
	x=300, y=280, length=80, width=20,
	fill="black", rotation=90
}


print(Shape.draw())


--[[
<!DOCTYPE html
     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>SVG Shapes</title>
  <style type="text/css">
    svg { border: 1px solid #ccc; }
  </style>
</head>
<body>
<svg width="800" height="600" xmlns="http://www.w3.org/2000/svg" version="1.1">
  <rect x="10" y="10" width="100" height="60" fill="skyblue" stroke="black" stroke-width="1" opacity="1" />
  <circle cx="200" cy="40" r="30" fill="pink" stroke="none" stroke-width="1" opacity="1" />
  <ellipse cx="300" cy="40" rx="40" ry="20" fill="lightgreen" stroke="none" stroke-width="1" opacity="1" />
  <line x1="350" y1="10" x2="450" y2="70" fill="none" stroke="purple" stroke-width="2" opacity="1" />
  <text x="20" y="120" fill="black" font-family="Calibri" font-size="30" font-weight="normal" stroke="none" stroke-width="1" opacity="1">Hello SVG!</text>
  <image x="480" y="10" width="50" height="50" href="https://upload.wikimedia.org/wikipedia/commons/4/47/PNG_transparency_demonstration_1.png" fill="none" stroke="none" stroke-width="1" opacity="1" />
  <polygon points="600,20 630,70 670,70 700,20 650,0" fill="orange" stroke="none" stroke-width="1" opacity="1" />
  <polyline points="10,150 24.285714285714285,180 38.57142857142857,150 52.857142857142854,180 67.14285714285714,150 81.42857142857143,180 95.71428571428571,150 110,180" fill="none" stroke="red" stroke-width="2" opacity="1" transform="rotate(10, 10, 150)" />
  <path d="M 150 180 L 160 192.13525491562422 L 170 194.2658477444273 L 180 184.63525491562422 L 190 171.1832212156129 L 200 165 L 210 171.1832212156129 L 220 184.6352549156242 L 230 194.2658477444273 L 240 192.13525491562422 L 250 180 L 260 167.86474508437578 L 270 165.7341522555727 L 280 175.3647450843758 L 290 188.81677878438705 L 300 195 L 310 188.81677878438708 L 320 175.3647450843758 L 330 165.7341522555727 L 340 167.86474508437576 L 350 180" fill="none" stroke="blue" stroke-width="2" opacity="1" transform="rotate(-10, 150, 180)" />
  <polygon points="400,180 460,180 430,130" fill="gold" stroke="none" stroke-width="1" opacity="1" />
  <polygon points="400,400 350,486.60254037844385 250.00000000000003,486.6025403784439 200,400 249.99999999999994,313.39745962155615 349.99999999999994,313.3974596215561" fill="red" stroke="black" stroke-width="2" opacity="1" />
  <polygon points="100,250 114.69463130731182,279.7745751406263 147.55282581475768,284.54915028125265 123.77641290737884,307.7254248593737 129.38926261462365,340.45084971874735 100,325 70.61073738537635,340.45084971874735 76.22358709262116,307.7254248593737 52.44717418524232,284.54915028125265 85.30536869268818,279.7745751406263" fill="violet" stroke="none" stroke-width="1" opacity="1" />
  <polygon points="190,280 190,220 180,220 200,200 220,220 210,220 210,280" fill="black" stroke="none" stroke-width="1" opacity="1" />
  <polygon points="290,280 290,220 280,220 300,200 320,220 310,220 310,280" fill="black" stroke="none" stroke-width="1" opacity="1" transform="rotate(90, 300, 280)" />
</svg>
</body>
</html>
]]
